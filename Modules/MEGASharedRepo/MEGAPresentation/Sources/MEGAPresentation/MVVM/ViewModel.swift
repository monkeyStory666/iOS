// Copyright Â© 2023 MEGA Limited. All rights reserved.

import Combine
import SwiftUI

public protocol BindableObject: ObservableObject {
    var cancellables: Set<AnyCancellable> { get set }
}

/// NoRoute is a simple enum used for defining a ViewModel that doesn't navigate to any route.
public enum NoRoute {}

/// NoRouteViewModel is a ViewModel that doesn't navigate to any route.
public typealias NoRouteViewModel = ViewModel<NoRoute>

open class ViewModel<Route>: ViewModelBase {
    @Published public var route: Route? {
        didSet { bindNewRoute(route) }
    }

    override public init() {
        super.init()
        let mirror = Mirror(reflecting: self)
        for child in mirror.children {
            if let viewProperty = child.value as? ViewPropertyProtocol {
                viewProperty.owner = self
            }
        }
    }

    /// This method is called whenever there's a new Route assigned to the `route` property.
    ///
    /// - Parameter route: The new route.
    ///
    /// This function should be overridden in subclasses of `ViewModel` that need to handle route
    /// changes with specific actions.
    /// When a new route is set, the overridden method can bind this new route to the necessary
    /// actions.
    ///
    /// For ViewModels with routes that require binding, not overriding this function would result
    /// in no actions being performed when the route changes.
    ///
    /// **Example Usage in a Subclass**:
    /// ```
    /// override func bindNewRoute(_ route: Route?) {
    ///     switch route {
    ///     case .presentAnotherView(let anotherViewModel):
    ///             bind(anotherViewModel) { ... }
    ///     default:
    ///         break
    ///     }
    /// }
    /// ```
    open func bindNewRoute(_ route: Route?) {
        // To be overriden
    }

    /// This method sets a new route to navigate to, optionally triggering an animation for the
    /// route change.
    ///
    /// - Parameters:
    ///   - route: The new route.
    ///   - shouldBeAnimated: A Boolean value that determines whether the route change should be
    /// animated. Defaults to `true`.
    ///
    /// This function should be used for changing the `route` property because it ensures that the
    /// changes are made on the main thread.
    /// Changes to `route` made outside of the main thread may result in UI inconsistencies or other
    /// threading-related issues.
    /// This method provides a safe way to handle route changes by encapsulating the dispatch to the
    /// main thread.
    ///
    /// If `shouldBeAnimated` is `true`, the function will trigger a UI animation for the route
    /// change.
    ///
    /// **Example Usage**:
    /// ```
    /// viewModel.routeTo(.home)
    /// viewModel.routeTo(.profile, withAnimation: false)
    /// ```
    public func routeTo(_ route: Route?, withAnimation shouldBeAnimated: Bool = true) {
        mainDispatchQueue.async {
            if shouldBeAnimated {
                withAnimation {
                    self.route = route
                }
            } else {
                self.route = route
            }
        }
    }
}

open class ViewModelBase: Identifiable, BindableObject {
    public var cancellables = Set<AnyCancellable>()
    public lazy var mainDispatchQueue: DispatchQueueType = {
        #if DEBUG
        if ProcessInfo.processInfo.environment["XCTestConfigurationFilePath"] != nil {
            return MockDispatchQueueMain()
        }
        #endif
        return DispatchQueue.main
    }()

    /// Method to observe changes on multiple publishers and automatically handle cancellation when
    /// not needed.
    ///
    /// - Parameter block: A closure which returns an array of AnyCancellable, generated by
    /// observing publishers.
    ///
    /// This method uses a result builder which allows for multiple `AnyCancellable` instances to be
    /// specified in a trailing closure.
    ///
    /// **Example Usages**:
    /// ```
    /// func observeDataChanges(with dataObserver: DataObserving) {
    ///     observe {
    ///         dataObserver.observeData().safelyAssign(to: \.data, on: self)
    ///         dataObserver.observeOtherData().safelyAssign(to: \.otherData, on: self)
    ///     }
    /// }
    /// ```
    /// In this example, `observeDataChanges(with:)` function observes changes in `data` and
    /// `otherData` using `dataObserver`.
    /// The changes are then safely assigned to the respective properties of `self`.
    public func observe(@CancellableBuilder _ block: () -> [AnyCancellable]) {
        cancellables.formUnion(block())
    }
}

@resultBuilder
public enum CancellableBuilder {
    public static func buildBlock(_ components: AnyCancellable...) -> [AnyCancellable] {
        components
    }
}

/// Function that binds publishers of a BindableObject to certain actions and ensures automatic
/// cancellation of observations when not needed.
///
/// - Parameters:
///   - bindableObject: The object that conforms to BindableObject protocol.
///   - block: A closure which returns an array of AnyCancellable, generated by observing publishers
/// of the bindableObject.
///
/// This function uses a result builder which allows for multiple `AnyCancellable` instances to be
/// specified in a trailing closure.
///
/// **Example Usages**:
/// ```
/// func bindDataForm() {
///     bind(dataFormToPresent) {
///         $0.$route.sink { [weak self] route in
///             guard let route else { return }
///
///             switch route {
///             case .updateData(let dataConfiguration):
///                 self?.dataUpdater.updateData(with: dataConfiguration)
///             case .cancelled:
///                 break
///             }
///             self?.dataFormToPresent = nil
///         }
///
///         $0.$isCanceling.sink { [weak self] isCanceling in
///             if isCanceling {
///                 self?.dataFormToPresent = nil
///             }
///         }
///     }
/// }
/// ```
/// In this example, `bindDataForm()` function binds the `route` and `isCanceling` publishers of a
/// `dataFormToPresent` to sinks which
/// handle updates, cancellations of data form presentation, and cancellation action.
public func bind<T: BindableObject>(
    _ bindableObject: T?,
    @CancellableBuilder _ block: (T) -> [AnyCancellable]
) {
    guard let bindableObject else { return }

    bindableObject.cancellables.formUnion(block(bindableObject))
}
